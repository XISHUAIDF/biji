注意输出是double的中间变量的类型也很重要
for循环依旧是检查的重点
中间状态的转移变量要检查
cin顺序也可能错
输出不分开，沾在一起
1f和lf不一样
数组怎么申明，int* arr=new int[n];
++c会提前+c，c++用完再+c
：当成；
（）没检查，当成{}
vector（n）是括号不是[ ]
快速排序没有看对递归，并且没有注意递归的终止条件，无限调用了
partition漏了i+1，并且最终i还留在循环内

进制转换出现的问题：
1.while的终结条件，没有意识到除法/截断会出现0
2.没有用到digit string
3.没有想到要翻转
sort(h.begin()+1,h.begin()+n+1);排序失败
+常数可以放在参数+

计数下标用本数

大失误之if后面的数据处理没有加{}
struct名字不要和申明的名字一样
自定义比较（cmp）想要什么true就
进制转换非常需要注意(snum[i]<='9' && snum[i] >= '0') =一定要排查
缓存问题
二分查找，递归mid做右mid-1，做左mid+1

dfs遍历穷举可能，特点是标记和回溯，标记完一种可能然后进行排序
dp动态规划在于子问题的拆分合并、转换

2025.5.18
利用杨辉三角形做组合c(n,n),上n不能大于下n，因为数组会溢出，用1ll*某数来转换为long long防溢出
全局变量数组初始化为0，找好谁是下n，谁是上n

2025.5.19
后续变历for循环可以从i=1开始赋值，然后方便后续遍历i-1
数组i、j变量混乱，数组下标变量赋值失误
没看懂问题，分段总结题意，输入输出一定要把握
后续遍历问题，防重计数一大误区
省变量省出四不像，输入输出定制版，后续完全不对
 ```cpp
for(int k=i-1;k>0;k--)`

          `if(M[k]>M[k+1]){`

            `while(M[k]==M[k-1]&&k>0){`

                `k--;`

            `}`

            ==`if(k+1!=i)swap(M[k],M[i]);`==

            ==`else{swap(M[k],M[k+1]);}`==

            `cnt++;}`

         `else{break;}` 
```

防重计数问题，新值加在后，可前向遍历
 ```cpp
   `for (int j = 1; j <= i; j++) {`

            `if (que[j] > que[i]) {`

                `swap(que[j], que[i]);`

                `cnt++;`

            `}`

```
deepseek做法，先维护一个prev只计数，然后再维护,分离开
```cpp
 int prev = -1; // 记录前一个不同的值
        for (int j = queue.size() - 2; j >= 0; j--) {
            if (queue[j] > val) {
                if (queue[j] != prev) { // 遇到新块
                    cnt++;
                    prev = queue[j];
                }
            } else {
                break; // 遇到小于等于的值，停止统计
            }
        }

        // 插入排序维护有序队列
        int pos = queue.size() - 1;
        while (pos > 0 && queue[pos] < queue[pos - 1]) {
            swap(queue[pos], queue[pos - 1]);
            pos--;
        }
```
老派逆向顺序，用while搜相同，注意，控制k的进度和搜重的x之间的问题
```cpp
   for(int k=i-1;k>0;k--){
            if(M[k]>M[k+1]){
            int x=k;
				while(x>1&&M[x-1]==M[x])x--;//如果与前一个相等，则指向前一个
				swap(M[x],M[k+1]);
				k=x;
				cnt++;
            }
        }
          
```

简单的字母转换题居然想到数组那块，其实不用，其实只需要
```cpp
if(m[i]>='a' && m[i]<='z'){

            a+= m[i] - 'a' +1;

        }else if(m[i]>='A' && m[i]<='Z'){

            a-=m[i];

        }
```


2025.5.20
数组溢出导致的输出错误


2025.5.22
依旧是 if(e[now].e ***0) now--; 注意int i=1的设计，i=0极其容易溢出***
***for循环还是一大的初始化痛点，特别注意回题目看***

