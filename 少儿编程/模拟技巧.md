 `
 int j=0,hast=0;

 bool sum =0;
 for(int i=0;i<n;i++){`

    `j=n-j+sum;`

    `sum = !sum;`

    `result +=(h[j]-hast)*(h[j]-hast);`

    `hast = h[j];`

  `}`
  来回跳代码，通过n-j+1跳左边，n-j+0跳右边，hast初始化兼保留上次、sum变化


2025.5.16
`int st_t(pair<char,char> st){`

    `int sl=st.first>='0'&&st.first<='9'?st.first-'0':st.first-'A'+10;`

    `int gl=st.second>='0'&&st.second<='9'?st.second-'0':st.second-'A'+10;`

    `return sl*16+gl;`

`}`

`int t_st(int t){`

    `return t<10?t+'0':t-10+'A';`

`}`经典的进制转换

```c
struct Node1{

    int p,e;

}e[N];

struct Node2{

    int a,b;

}f[N],g[N];

bool cmp1(Node1 x,Node1 y){

    return x.p<y.p;

}

bool cmp2(Node2 x,Node2 y){

    return x.a - x.b > y.a - y.b;

}

  

bool cmp3(Node2 x,Node2 y){

    return x.b - x.a > y.b -y.a;
```
对于多对比较，设置struct和对比函数